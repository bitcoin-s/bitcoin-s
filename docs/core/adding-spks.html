<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Adding New Script Types · bitcoin-s</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;"/><meta name="docsearch:version" content="1.9.10"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Adding New Script Types · bitcoin-s"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bitcoin-s.org/"/><meta property="og:description" content="&lt;!-- START doctoc generated TOC please keep comment here to allow auto update --&gt;"/><meta property="og:image" content="https://bitcoin-s.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://bitcoin-s.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-61958686-2', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="https://fonts.googleapis.com/css?family=Montserrat:500"></script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-61958686-2"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="bitcoin-s"/><h2 class="headerTitleWithLogo">bitcoin-s</h2></a><a href="/versions"><h3>1.9.10</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/core/core-intro" target="_self">Docs</a></li><li class=""><a href="/download" target="_self">Download</a></li><li class=""><a href="/api/org/bitcoins" target="_self">API</a></li><li class=""><a href="/help" target="_self">Help</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Core Module</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/getting-started">Intro and Getting Started</a></li><li class="navListItem"><a class="navItem" href="/docs/bips">Supported BIPs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Setup</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/getting-setup">Getting Bitcoin-S installed on your machine</a></li><li class="navListItem"><a class="navItem" href="/docs/ui-setup">Installing the DLC Wallet UI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Applications</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/applications/cli">CLI</a></li><li class="navListItem"><a class="navItem" href="/docs/applications/server">Application Server</a></li><li class="navListItem"><a class="navItem" href="/docs/applications/gui">GUI</a></li><li class="navListItem"><a class="navItem" href="/docs/applications/server-systemd">Systemd installation</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Chain</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/chain/chain">Blockchain Verification</a></li><li class="navListItem"><a class="navItem" href="/docs/chain/filter-sync">Syncing Blockfilters</a></li><li class="navListItem"><a class="navItem" href="/docs/chain/chain-query-api">Chain Query API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Configuration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/config/configuration">Application Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Core Module</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/core/core-intro">Core Module</a></li><li class="navListItem"><a class="navItem" href="/docs/core/addresses">Generating Addresses</a></li><li class="navListItem"><a class="navItem" href="/docs/core/hd-keys">HD Key Generation</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/core/adding-spks">Adding New Script Types</a></li><li class="navListItem"><a class="navItem" href="/docs/core/spending-info">Signing Transactions</a></li><li class="navListItem"><a class="navItem" href="/docs/core/psbts">Partially Signed Bitcoin Transactions</a></li><li class="navListItem"><a class="navItem" href="/docs/core/dlc">Discreet Log Contract Data Structures</a></li><li class="navListItem"><a class="navItem" href="/docs/core/txbuilder">TxBuilder Example</a></li><li class="navListItem"><a class="navItem" href="/docs/core/lightning-network">Lightning Network Data Types</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Crypto Module</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/crypto/crypto-intro">Crypto Module</a></li><li class="navListItem"><a class="navItem" href="/docs/crypto/sign">Sign API</a></li><li class="navListItem"><a class="navItem" href="/docs/crypto/adaptor-signatures">Adaptor Signatures</a></li><li class="navListItem"><a class="navItem" href="/docs/crypto/musig">MuSig</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Fee Provider</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fee-provider/fee-provider">Fee Provider</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Key Manager</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/key-manager/server-key-manager">Server Key Manager</a></li><li class="navListItem"><a class="navItem" href="/docs/key-manager/key-manager">Key Manager</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Node</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/node/node">Light Client</a></li><li class="navListItem"><a class="navItem" href="/docs/node/node-api">Node API</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Wallet</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet">Wallet</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-callbacks">Wallet Callbacks</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-get-address">Wallet Get Address APIs</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/address-tagging">Address and UTXO tagging</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/dlc">Executing A DLC with Bitcoin-S</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-rescan">Wallet Rescans</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-sync">Wallet Sync</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-rpc">Wallet RPC Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/backups">Wallet Backups</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-election-example">Wallet Election Example</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-price-example">Wallet Price Example</a></li><li class="navListItem"><a class="navItem" href="/docs/wallet/wallet-sports-betting-example">Wallet Sports Betting Example</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tor</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tor/tor">Tor Setup</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">RPC Clients</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/rpc/rpc-clients-intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/rpc/rpc-eclair">Eclair</a></li><li class="navListItem"><a class="navItem" href="/docs/rpc/rpc-bitcoind">bitcoind/Bitcoin Core</a></li><li class="navListItem"><a class="navItem" href="/docs/rpc/lnd-rpc">LND</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Secp256k1</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/secp256k1/secp256k1">Secp256k1</a></li><li class="navListItem"><a class="navItem" href="/docs/secp256k1/jni-modify">Adding to Secp256k1 JNI</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Testkit</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/testkit/testkit">Testkit</a></li><li class="navListItem"><a class="navItem" href="/docs/testkit/testkit-core">Testkit Core</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">DLC Oracle</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/oracle/build-oracle-server">Building the Oracle Server</a></li><li class="navListItem"><a class="navItem" href="/docs/oracle/oracle-server">Oracle Server</a></li><li class="navListItem"><a class="navItem" href="/docs/oracle/oracle-election-example">Election Example</a></li><li class="navListItem"><a class="navItem" href="/docs/oracle/oracle-price-example">Price Example</a></li><li class="navListItem"><a class="navItem" href="/docs/oracle/oracle-sports-betting-example">Sports Betting Example</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Oracle Explorer Client</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/oracle-explorer-client/oracle-explorer-client">Oracle Explorer Client</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Contributing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/contributing">Contributing</a></li><li class="navListItem"><a class="navItem" href="/docs/contributing-website">Contributing to the website</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Security</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/security">Security</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/bitcoin-s/bitcoin-s/blob/master/docs/core/adding-spks.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Adding New Script Types</h1></header><article><div><span><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- END doctoc -->
<ul>
<li><a href="#adding-a-new-scriptpubkey-type">Adding a New ScriptPubKey Type</a>
<ul>
<li><a href="#step-0-design-philosophy">Step 0: Design Philosophy</a></li>
<li><a href="#step-1-create-a-new-scriptpubkey-trait">Step 1: Create a New ScriptPubKey Trait</a></li>
<li><a href="#step-2-create-companion-object">Step 2: Create Companion Object</a></li>
<li><a href="#step-3-add-to-relevant-fromasm-methods">Step 3: Add to Relevant fromAsm Methods</a></li>
<li><a href="#step-4-create-a-scriptsignature-if-necessary">Step 4: Create a ScriptSignature If Necessary</a></li>
<li><a href="#step-5-add-to-scriptsignaturefromasm-if-applicable">Step 5: Add to ScriptSignature.fromAsm If Applicable</a></li>
<li><a href="#step-6-create-relevant-bitcoinutxospendinginfo">Step 6: Create Relevant BitcoinUTXOSpendingInfo</a>
<ul>
<li><a href="#non-nested-single-key-spending-info">Non-Nested Single-Key Spending Info</a></li>
<li><a href="#non-nested-multi-key-spending-info">Non-Nested Multi-Key Spending Info</a></li>
<li><a href="#nested-spending-info">Nested Spending Info</a></li>
</ul></li>
<li><a href="#step-7-add-to-relevant-apply-methods">Step 7: Add to Relevant Apply Methods</a></li>
<li><a href="#step-8-create-a-signer">Step 8: Create a Signer</a>
<ul>
<li><a href="#non-nested-single-key-spending-info-1">Non-Nested Single-Key Spending Info</a></li>
<li><a href="#non-nested-multi-key-spending-info-1">Non-Nested Multi-Key Spending Info</a></li>
<li><a href="#nested-spending-info-1">Nested Spending Info</a></li>
</ul></li>
<li><a href="#step-9-add-to-bitcoinsignersign">Step 9: Add to BitcoinSigner.sign</a></li>
<li><a href="#step-10-add-to-scriptgenerators">Step 10: Add to ScriptGenerators</a>
<ul>
<li><a href="#scriptpubkey-generator">ScriptPubKey Generator</a></li>
<li><a href="#scriptsignature-generator">ScriptSignature Generator</a></li>
<li><a href="#scriptpubkey-with-paired-scriptsignature-generator">ScriptPubKey with Paired ScriptSignature Generator</a></li>
</ul></li>
<li><a href="#step-11-add-to-creditingtxgen">Step 11: Add to CreditingTxGen</a></li>
<li><a href="#step-12-fix-all-non-exhaustive-matches">Step 12: Fix all Non-Exhaustive Matches</a></li>
<li><a href="#step-13-run-tests-and-debug">Step 13: Run tests and debug</a></li>
</ul></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1><a class="anchor" aria-hidden="true" id="adding-a-new-scriptpubkey-type"></a><a href="#adding-a-new-scriptpubkey-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding a New ScriptPubKey Type</h1>
<p>In this document, we will describe how to add new script implementations and types in Bitcoin-S. We will use the following script template example which we have called P2PK with Timeout to illustrate the process:</p>
<pre><code class="hljs"><span class="hljs-attribute">OP_IF</span>
    <span class="hljs-section">&lt;Public Key&gt;</span>
<span class="hljs-attribute">OP_ELSE</span>
    <span class="hljs-section">&lt;Timeout&gt;</span> <span class="hljs-attribute">OP_CHECKSEQUENCEVERIFY</span> OP_DROP
    <span class="hljs-section">&lt;Timeout Public Key&gt;</span>
<span class="hljs-attribute">OP_ENDIF</span>
<span class="hljs-attribute">OP_CHECKSIG</span>
</code></pre>
<p>Here is <a href="https://github.com/bitcoin-s/bitcoin-s/pull/967">the actual pull request</a> in which a very similar <code>ScriptPubKey</code> is implemented in Bitcoin-S.</p>
<p>Please note that this document only explains how to add new <code>RawScriptPubKey</code>s which are the subset of <code>ScriptPubKey</code>s which are fully described by their raw scripts. This is to say that this guide will not help in implementing a new segwit version, but should be helpful for most anything else.</p>
<p>It is also important to note that all new scripts should be implemented as if they are to appear on-chain without any P2SH or P2WSH. Bitcoin-S already supports conversions from raw on-chain scripts to these formats in the constructors for the script hash schemes which does not require extra support for new script types.</p>
<h2><a class="anchor" aria-hidden="true" id="step-0-design-philosophy"></a><a href="#step-0-design-philosophy" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 0: Design Philosophy</h2>
<p>Bitcoin-S strives to have script types defined in such a way that they can be easily composed and reused. Before going through this guide and implementing a really large script template type, try to decompose your script into smaller re-usable pieces.</p>
<p>Also remember to consider what existing pieces you can use. For example, <code>LockTimeScriptPubKey</code>s are implemented in such a way that any other <code>RawScriptPubKey</code> can be given a time lock by nesting it within a <code>LockTimeScriptPubKey</code> subtype. Likewise, <code>ConditionalScriptPubKey</code>s are built to allow any other <code>RawScriptPubKey</code> type to populate both the <code>OP_IF/OP_NOTIF</code> case and the <code>OP_ELSE</code> case.</p>
<h2><a class="anchor" aria-hidden="true" id="step-1-create-a-new-scriptpubkey-trait"></a><a href="#step-1-create-a-new-scriptpubkey-trait" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 1: Create a New ScriptPubKey Trait</h2>
<p>Go to <code>ScriptPubKey.scala</code> and add a new trait:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">P2PKWithTimeoutScriptPubKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RawScriptPubKey</span></span>
</code></pre>
<p>You will then want to add all of the relevant accessor methods. For our case of P2PKWithTimeout, this will mean giving access to the public key, timeout, and timeout public key. Lastly, you will want to add a scaladoc. In total, we get the following result:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">/** The type for ScriptPubKeys of the form:
  * OP_IF
  *   &lt;Public Key&gt;
  * OP_ELSE
  *   &lt;Timeout&gt; OP_CHECKSEQUENCEVERIFY OP_DROP
  *   &lt;Timeout Public Key&gt;
  * OP_ENDIF
  * OP_CHECKSIG
  */</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">P2PKWithTimeoutScriptPubKey</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RawScriptPubKey</span> </span>{

  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> pubKey: <span class="hljs-type">ECPublicKey</span> =
    <span class="hljs-type">ECPublicKey</span>.fromBytes(<span class="hljs-keyword">this</span>.asm(<span class="hljs-number">2</span>).bytes)

  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> lockTime: <span class="hljs-type">ScriptNumber</span> = <span class="hljs-type">ScriptNumber</span>.fromBytes(<span class="hljs-keyword">this</span>.asm(<span class="hljs-number">5</span>).bytes)

  <span class="hljs-keyword">lazy</span> <span class="hljs-keyword">val</span> timeoutPubKey: <span class="hljs-type">ECPublicKey</span> =
    <span class="hljs-type">ECPublicKey</span>.fromBytes(<span class="hljs-keyword">this</span>.asm(<span class="hljs-number">9</span>).bytes)
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-2-create-companion-object"></a><a href="#step-2-create-companion-object" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 2: Create Companion Object</h2>
<p>We now need a companion object which will fulfill four functionalities for us:</p>
<ol>
<li>Contain a concrete <code>Impl</code> class for our SPK type
<ul>
<li>This simply means creating a <code>private case class</code> wrapping <code>asm: Vector[ScriptToken]</code></li>
</ul></li>
<li>Create a <code>fromAsm</code> constructor
<ul>
<li>This should be a simple call to <code>buildScript</code> which is inherited from <code>ScriptFactory</code></li>
</ul></li>
<li>Create a logical constructor from Bitcoin-S types
<ul>
<li>This means creating an <code>apply</code> method that takes in logical BItcoin-S types and constructs asm</li>
<li>Note that this may require the use of <code>BitcoinScriptUtil.calculatePushOp</code></li>
</ul></li>
<li>Create an ASM filter which will detect if a given <code>Vector[ScriptToken]</code> corresponds to our type</li>
</ol>
<p>This looks like the following:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">P2PKWithTimeoutScriptPubKey</span></span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">ScriptFactory</span>[<span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>] {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P2PKWithTimeoutScriptPubKeyImpl</span>(<span class="hljs-params">asm: <span class="hljs-type">Vector</span>[<span class="hljs-type">ScriptToken</span>]</span>)</span>
      <span class="hljs-keyword">extends</span> <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromAsm</span></span>(asm: <span class="hljs-type">Seq</span>[<span class="hljs-type">ScriptToken</span>]): <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span> = {
    buildScript(
      asm = asm.toVector,
      constructor = <span class="hljs-type">P2PKWithTimeoutScriptPubKeyImpl</span>.apply,
      errorMsg = <span class="hljs-string">s"Given asm was not a P2PKWithTimeoutScriptPubKey, got <span class="hljs-subst">$asm</span>"</span>
    )
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(
      pubKey: <span class="hljs-type">ECPublicKey</span>,
      lockTime: <span class="hljs-type">ScriptNumber</span>,
      timeoutPubKey: <span class="hljs-type">ECPublicKey</span>): <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span> = {
    <span class="hljs-keyword">val</span> timeoutAsm = <span class="hljs-type">CSVScriptPubKey</span>(lockTime, <span class="hljs-type">EmptyScriptPubKey</span>).asm.toVector
    <span class="hljs-keyword">val</span> pubKeyAsm = <span class="hljs-type">BitcoinScriptUtil</span>
      .calculatePushOp(pubKey.bytes)
      .toVector ++ <span class="hljs-type">Vector</span>(<span class="hljs-type">ScriptConstant</span>(pubKey.bytes))
    <span class="hljs-keyword">val</span> timeoutPubKeyAsm = <span class="hljs-type">BitcoinScriptUtil</span>
      .calculatePushOp(timeoutPubKey.bytes)
      .toVector ++ <span class="hljs-type">Vector</span>(<span class="hljs-type">ScriptConstant</span>(timeoutPubKey.bytes))

    <span class="hljs-type">P2PKWithTimeoutScriptPubKeyImpl</span>(
      <span class="hljs-type">Vector</span>(<span class="hljs-type">Vector</span>(<span class="hljs-type">OP_IF</span>),
             pubKeyAsm,
             <span class="hljs-type">Vector</span>(<span class="hljs-type">OP_ELSE</span>),
             timeoutAsm,
             timeoutPubKeyAsm,
             <span class="hljs-type">Vector</span>(<span class="hljs-type">OP_ENDIF</span>, <span class="hljs-type">OP_CHECKSIG</span>)).flatten
    )
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidAsm</span></span>(asm: <span class="hljs-type">Seq</span>[<span class="hljs-type">ScriptToken</span>]): <span class="hljs-type">Boolean</span> = {
    <span class="hljs-keyword">if</span> (asm.length == <span class="hljs-number">12</span>) {
      <span class="hljs-keyword">val</span> pubKey = <span class="hljs-type">ECPublicKey</span>.fromBytes(asm(<span class="hljs-number">2</span>).bytes)
      <span class="hljs-keyword">val</span> lockTimeTry = <span class="hljs-type">Try</span>(<span class="hljs-type">ScriptNumber</span>.fromBytes(asm(<span class="hljs-number">5</span>).bytes))
      <span class="hljs-keyword">val</span> timeoutPubKey = <span class="hljs-type">ECPublicKey</span>.fromBytes(asm(<span class="hljs-number">9</span>).bytes)

      lockTimeTry <span class="hljs-keyword">match</span> {
        <span class="hljs-keyword">case</span> <span class="hljs-type">Success</span>(lockTime) =&gt;
          asm == <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>(pubKey, lockTime, timeoutPubKey).asm
        <span class="hljs-keyword">case</span> <span class="hljs-type">Failure</span>(_) =&gt; <span class="hljs-literal">false</span>
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-literal">false</span>
    }
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-3-add-to-relevant-fromasm-methods"></a><a href="#step-3-add-to-relevant-fromasm-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 3: Add to Relevant fromAsm Methods</h2>
<p>We now need to ensure that <code>ScriptPubKey.fromAsm(p2pkWithTimeoutSPK.asm)</code> returns our type. Since <code>P2PKWithTimeoutScriptPubKey extends RawScriptPubKey</code>, this means we must add to <code>RawScriptPubKey.fromAsm</code>. Note that order in this function's <code>match</code> can matter. Since our type is more specific than any other currently existing type, we put our new <code>case</code> at the top:</p>
<pre><code class="hljs css language-scala">asm <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Nil</span> =&gt; <span class="hljs-type">EmptyScriptPubKey</span>
    <span class="hljs-keyword">case</span> _ <span class="hljs-keyword">if</span> <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>.isValidAsm(asm) =&gt;
      <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>.fromAsm(asm)
    <span class="hljs-comment">//...</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-4-create-a-scriptsignature-if-necessary"></a><a href="#step-4-create-a-scriptsignature-if-necessary" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 4: Create a ScriptSignature If Necessary</h2>
<p>Often times a new <code>ScriptSignature</code> type will be necessary when introducing a new <code>ScriptPubKey</code> type. When this is the case, the procedure for adding a new <code>ScriptSignature</code> is more or less identical to steps 1 and 2 above. Here is what this looks like for <code>P2PKScriptPubKey</code> (note, this is not <code>P2PKWithTimeoutScriptPubKey</code>):</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">/**
  * Represents a pay to public key script signature
  * https://bitcoin.org/en/developer-guide#pubkey
  * Signature script: &lt;sig&gt;
  */</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">P2PKScriptSignature</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ScriptSignature</span> </span>{

  <span class="hljs-comment">/** PubKey scriptSignatures only have one signature */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signature</span></span>: <span class="hljs-type">ECDigitalSignature</span> = signatures.head

  <span class="hljs-comment">/** The digital signatures inside of the scriptSig */</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signatures</span></span>: <span class="hljs-type">Seq</span>[<span class="hljs-type">ECDigitalSignature</span>] = {
    <span class="hljs-type">Seq</span>(<span class="hljs-type">ECDigitalSignature</span>(<span class="hljs-type">BitcoinScriptUtil</span>.filterPushOps(<span class="hljs-keyword">this</span>.asm).head.hex))
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toString</span> </span>= <span class="hljs-string">s"P2PKScriptSignature(<span class="hljs-subst">$signature</span>)"</span>
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">P2PKScriptSignature</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ScriptFactory</span>[<span class="hljs-type">P2PKScriptSignature</span>] </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P2PKScriptSignatureImpl</span>(<span class="hljs-params">
      override val asm: <span class="hljs-type">Vector</span>[<span class="hljs-type">ScriptToken</span>]</span>)</span>
      <span class="hljs-keyword">extends</span> <span class="hljs-type">P2PKScriptSignature</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromAsm</span></span>(asm: <span class="hljs-type">Seq</span>[<span class="hljs-type">ScriptToken</span>]): <span class="hljs-type">P2PKScriptSignature</span> = {
    buildScript(asm.toVector,
                <span class="hljs-type">P2PKScriptSignatureImpl</span>(_),
                <span class="hljs-string">"The given asm tokens were not a p2pk script sig: "</span> + asm)
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(signature: <span class="hljs-type">ECDigitalSignature</span>): <span class="hljs-type">P2PKScriptSignature</span> = {
    <span class="hljs-keyword">val</span> pushOps = <span class="hljs-type">BitcoinScriptUtil</span>.calculatePushOp(signature.bytes)
    <span class="hljs-keyword">val</span> signatureConstant = <span class="hljs-type">ScriptConstant</span>(signature.bytes)
    <span class="hljs-keyword">val</span> asm = pushOps ++ <span class="hljs-type">Seq</span>(signatureConstant)
    <span class="hljs-type">P2PKScriptSignature</span>.fromAsm(asm)
  }

  <span class="hljs-comment">/** P2PK scriptSigs always have the pattern [pushop, digitalSignature] */</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidAsm</span></span>(asm: <span class="hljs-type">Seq</span>[<span class="hljs-type">ScriptToken</span>]): <span class="hljs-type">Boolean</span> = asm <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Seq</span>(_: <span class="hljs-type">BytesToPushOntoStack</span>, _: <span class="hljs-type">ScriptConstant</span>) =&gt; <span class="hljs-literal">true</span>
    <span class="hljs-keyword">case</span> _                                               =&gt; <span class="hljs-literal">false</span>
  }
}
</code></pre>
<p>However, it is sometimes not necessary to create a new <code>ScriptSignature</code> type for every new <code>ScriptPubKey</code>. This is because we want to maintain unique representations for every <code>ScriptSignature</code>, and it turns out that in our case of <code>P2PKWithTimeoutScriptPubKey</code>, script signatures are of the form</p>
<pre><code class="hljs"><span class="hljs-section">&lt;boolean&gt;</span> <span class="hljs-section">&lt;signautre&gt;</span>
</code></pre>
<p>which is already represented by <code>ConditionalScriptSignature</code>. When this happens, you only need to create an <code>object</code> for your new type, and then follow step 2 above, skipping the first part (adding an Impl <code>case class</code>):</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">P2PKWithTimeoutScriptSignature</span></span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">ScriptFactory</span>[<span class="hljs-type">ConditionalScriptSignature</span>] {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromAsm</span></span>(asm: <span class="hljs-type">Seq</span>[<span class="hljs-type">ScriptToken</span>]): <span class="hljs-type">ConditionalScriptSignature</span> = {
    buildScript(
      asm.toVector,
      <span class="hljs-type">ConditionalScriptSignature</span>.fromAsm,
      <span class="hljs-string">s"The given asm tokens were not a P2PKWithTimeoutScriptSignature, got <span class="hljs-subst">$asm</span>"</span>
    )
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(
      beforeTimeout: <span class="hljs-type">Boolean</span>,
      signature: <span class="hljs-type">ECDigitalSignature</span>): <span class="hljs-type">ConditionalScriptSignature</span> = {
    <span class="hljs-type">ConditionalScriptSignature</span>(<span class="hljs-type">P2PKScriptSignature</span>(signature), beforeTimeout)
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValidAsm</span></span>(asm: <span class="hljs-type">Seq</span>[<span class="hljs-type">ScriptToken</span>]): <span class="hljs-type">Boolean</span> = {
    <span class="hljs-type">P2PKScriptSignature</span>.isValidAsm(asm.dropRight(<span class="hljs-number">1</span>)) &amp;&amp; <span class="hljs-type">ConditionalScriptSignature</span>
      .isValidAsm(asm)
  }
}
</code></pre>
<p>Remember that in all of them above, <code>ScriptSignature</code>s are written as if they are to appear on-chain in transaction inputs rather than transaction witnesses, since Bitcoin-S supports turning any raw <code>ScriptSignature</code> into a <code>P2WSHWitness</code> without requiring explicit support for new script types.</p>
<h2><a class="anchor" aria-hidden="true" id="step-5-add-to-scriptsignaturefromasm-if-applicable"></a><a href="#step-5-add-to-scriptsignaturefromasm-if-applicable" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 5: Add to ScriptSignature.fromAsm If Applicable</h2>
<p>If you added a new <code>ScriptSignature</code> type in the previous step, you must add a <code>case</code> to the <code>match</code> statement in <code>ScriptSignature.fromAsm</code> at the bottom of <code>ScriptSignature.scala</code>. For <code>P2PKScriptSignature</code> (note that this does not apply to <code>P2PKWithTimeoutScriptSignature</code> since there is no new unique type for this <code>ScriptSignature</code>), this looks like:</p>
<pre><code class="hljs css language-scala">tokens <span class="hljs-keyword">match</span> {
  <span class="hljs-comment">//...</span>
  <span class="hljs-keyword">case</span> _ <span class="hljs-keyword">if</span> <span class="hljs-type">P2PKScriptSignature</span>.isValidAsm(tokens) =&gt;
      <span class="hljs-type">P2PKScriptSignature</span>.fromAsm(tokens)
  <span class="hljs-comment">//...</span>
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-6-create-relevant-inputinfo"></a><a href="#step-6-create-relevant-inputinfo" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 6: Create Relevant InputInfo</h2>
<p><code>InputInfo</code> is the Bitcoin-S data structure for the information required to spend from a specific condition of a given <code>ScriptPubKey</code> other than private keys. Hence, when defining new script types, it is important to define how they are spent as well so that they can be useful.</p>
<p>There are two distinct kinds of scripts when it comes to signing in Bitcoin-S: scripts that have nesting (such as <code>ConditionalScriptPubKey</code>, <code>P2SHScriptPubKey</code>) and scripts without nesting (such as <code>MultiSignatureScriptPubKey</code>, <code>P2PKWithTimeoutScriptPubKey</code>, <code>P2PKHScriptPubKey</code>). We will cover each of these cases in turn, starting with the latter case as it applies to our example of <code>P2PKWithTimeout</code>. In both cases, please make sure to validate any parameter data using <code>require</code> statements when necessary, but make things correct by construction instead whenever possible. For example, if there is a redeem script and a <code>ScriptPubKey</code> which must wrap this redeem script, take as a parameter only the redeem script and construct the <code>ScriptPubKey</code> internally so that it is sure to be consistent.</p>
<h3><a class="anchor" aria-hidden="true" id="non-nesting-input-info"></a><a href="#non-nesting-input-info" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Non-Nesting Input Info</h3>
<p>We create a new <code>case class</code> in <code>InputInfo.scala</code> which extends <code>RawInputInfo</code> and which contains in its parameters, all of the info required for spending a specific condition other than private keys and <code>HashType</code>. Here is what this looks like for <code>P2PKWithTimeout</code>:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P2PKWithTimeoutInputInfo</span>(<span class="hljs-params">
    outPoint: <span class="hljs-type">TransactionOutPoint</span>,
    amount: <span class="hljs-type">CurrencyUnit</span>,
    scriptPubKey: <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>,
    isBeforeTimeout: <span class="hljs-type">Boolean</span></span>)</span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">RawInputInfo</span> {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">conditionalPath</span></span>: <span class="hljs-type">ConditionalPath</span> = {
    <span class="hljs-keyword">if</span> (isBeforeTimeout) {
      <span class="hljs-type">ConditionalPath</span>.nonNestedTrue
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-type">ConditionalPath</span>.nonNestedFalse
    }
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pubKeys</span></span>: <span class="hljs-type">Vector</span>[<span class="hljs-type">ECPublicKey</span>] =
    <span class="hljs-type">Vector</span>(scriptPubKey.pubKey, scriptPubKey.timeoutPubKey)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="nested-spending-info"></a><a href="#nested-spending-info" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested Spending Info</h3>
<p>The one new thing in the nested case is that we must create a <code>val nestedSpendingInfo: RawInputInfo</code> and make sure to pass on <code>hashPreImages: Vector[NetworkElement]</code> to the nested <code>InputInfo</code>, and pull public keys from the <code>nestedInputInfo</code>. For the case of spending <code>LockTimeScriptPubKey</code>s, this looks like the following:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTimeInputInfo</span>(<span class="hljs-params">
    outPoint: <span class="hljs-type">TransactionOutPoint</span>,
    amount: <span class="hljs-type">CurrencyUnit</span>,
    scriptPubKey: <span class="hljs-type">LockTimeScriptPubKey</span>,
    conditionalPath: <span class="hljs-type">ConditionalPath</span>,
    hashPreImages: <span class="hljs-type">Vector</span>[<span class="hljs-type">NetworkElement</span>] = <span class="hljs-type">Vector</span>.empty
</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">RawInputInfo</span> </span>{

  <span class="hljs-keyword">val</span> nestedInputInfo: <span class="hljs-type">RawInputInfo</span> = <span class="hljs-type">RawInputInfo</span>(
    outPoint,
    amount,
    scriptPubKey.nestedScriptPubKey,
    conditionalPath,
    hashPreImages)

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pubKeys</span></span>: <span class="hljs-type">Vector</span>[<span class="hljs-type">ECPublicKey</span>] = nestedInputInfo.pubKeys
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-7-add-to-relevant-apply-methods"></a><a href="#step-7-add-to-relevant-apply-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 7: Add to Relevant Apply Methods</h2>
<p>Now that we have created our new <code>RawInputInfo</code>, we need to add them to the general-purpose input info constructors. This means adding a <code>case</code> to <code>RawInputInfo.apply</code> for your new <code>ScriptPubKey</code> type which constructs your relevant <code>RawInputInfo</code> from generic types (given as parameters in the <code>apply</code> methods). For <code>P2PKWithTimeout</code>, this looks like the following:</p>
<pre><code class="hljs css language-scala">scriptPubKey <span class="hljs-keyword">match</span> {
      <span class="hljs-comment">//...</span>
      <span class="hljs-keyword">case</span> p2pkWithTimeout: <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span> =&gt;
              conditionalPath.headOption <span class="hljs-keyword">match</span> {
                <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt;
                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(
                    <span class="hljs-string">"ConditionalPath must be specified for P2PKWithTimeout"</span>)
                <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(beforeTimeout) =&gt;
                  <span class="hljs-type">P2PKWithTimeoutInputInfo</span>(outPoint,
                                           amount,
                                           p2pkWithTimeout,
                                           beforeTimeout)
              }
      <span class="hljs-comment">//...</span>
    }
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-8-create-a-signer"></a><a href="#step-8-create-a-signer" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 8: Create a Signer</h2>
<p>We must now add signing functionality for our new script type within <code>Signer.scala</code>. This time, we have three different cases depending on your new script type.</p>
<h3><a class="anchor" aria-hidden="true" id="non-nested-single-key-spending-info"></a><a href="#non-nested-single-key-spending-info" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Non-Nested Single-Key Spending Info</h3>
<p>For the non-nested case where only a single key is required, all we must do is create a new class which extends <code>RawSingleKeyBitcoinSigner</code> and implements <code>keyAndSigToScriptSig</code>. For <code>P2PKWithTimeout</code> this looks like the following:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P2PKWithTimeoutSigner</span></span>
    <span class="hljs-keyword">extends</span> <span class="hljs-type">RawSingleKeyBitcoinSigner</span>[<span class="hljs-type">P2PKWithTimeoutInputInfo</span>] {

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">keyAndSigToScriptSig</span></span>(
      key: <span class="hljs-type">ECPublicKey</span>,
      sig: <span class="hljs-type">ECDigitalSignature</span>,
      spendingInfo: <span class="hljs-type">UTXOInfo</span>[<span class="hljs-type">P2PKWithTimeoutInputInfo</span>]): <span class="hljs-type">ScriptSignature</span> = {
    <span class="hljs-type">P2PKWithTimeoutScriptSignature</span>(spendingInfo.inputInfo.isBeforeTimeout, sig)
  }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">P2PKWithTimeoutSigner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">P2PKWithTimeoutSigner</span></span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="non-nested-multi-key-spending-info"></a><a href="#non-nested-multi-key-spending-info" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Non-Nested Multi-Key Spending Info</h3>
<p>In the non-nested case where multiple keys are required, we must create a new <code>Signer</code>, which requires implementing the <code>sign</code> function. For <code>MultiSignature</code> this looks like the following:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiSigSigner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Signer</span>[<span class="hljs-type">MultiSignatureInputInfo</span>] </span>{

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign</span></span>(
      spendingInfo: <span class="hljs-type">UTXOSatisfyingInfo</span>[<span class="hljs-type">InputInfo</span>],
      unsignedTx: <span class="hljs-type">Transaction</span>,
      spendingInfoToSatisfy: <span class="hljs-type">UTXOSatisfyingInfo</span>[<span class="hljs-type">MultiSignatureInputInfo</span>])(
      <span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>): <span class="hljs-type">Future</span>[<span class="hljs-type">TxSigComponent</span>] = {
    <span class="hljs-keyword">val</span> (_, output, inputIndex, _) =
      relevantInfo(spendingInfo, unsignedTx)

    <span class="hljs-keyword">val</span> keysAndSigsF = spendingInfo.toSingles.map { spendingInfoSingle =&gt;
      signSingle(spendingInfoSingle, unsignedTx)
    }

    <span class="hljs-keyword">val</span> signaturesF = <span class="hljs-type">Future</span>.sequence(keysAndSigsF).map(_.map(_.signature))

    <span class="hljs-keyword">val</span> scriptSigF = signaturesF.map { sigs =&gt;
      <span class="hljs-type">MultiSignatureScriptSignature</span>(sigs)
    }

    updateScriptSigInSigComponent(unsignedTx,
                                  inputIndex.toInt,
                                  output,
                                  scriptSigF)
  }
}

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">MultiSigSigner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MultiSigSigner</span></span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="nested-spending-info-1"></a><a href="#nested-spending-info-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested Spending Info</h3>
<p>When signing for a nested script structure, we must create a new <code>Signer</code>. You will need to make a delegating call with the <code>nestedSpendingInfo</code> to <code>BitcoinSigner.sign</code>, but you may also need to do whatever else is needed with the nested result to construct a correct <code>ScriptSignature</code>. For <code>ConditionalScriptSignature</code>, this all looks like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">/** Delegates to get a ScriptSignature for the case being
  * spent and then adds an OP_TRUE or OP_FALSE
  */</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionalSigner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Signer</span>[<span class="hljs-type">ConditionalInputInfo</span>] </span>{

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sign</span></span>(
      spendingInfo: <span class="hljs-type">UTXOSatisfyingInfo</span>[<span class="hljs-type">InputInfo</span>],
      unsignedTx: <span class="hljs-type">Transaction</span>,
      spendingInfoToSatisfy: <span class="hljs-type">UTXOSatisfyingInfo</span>[<span class="hljs-type">ConditionalInputInfo</span>])(
      <span class="hljs-keyword">implicit</span> ec: <span class="hljs-type">ExecutionContext</span>): <span class="hljs-type">Future</span>[<span class="hljs-type">TxSigComponent</span>] = {
    <span class="hljs-keyword">val</span> (_, output, inputIndex, _) = relevantInfo(spendingInfo, unsignedTx)

    <span class="hljs-keyword">val</span> nestedSpendingInfo = spendingInfoToSatisfy.copy(
      inputInfo = spendingInfoToSatisfy.inputInfo.nestedInputInfo)

    <span class="hljs-keyword">val</span> missingOpSigComponentF = <span class="hljs-type">BitcoinSigner</span>.sign(spendingInfo,
                                                    unsignedTx,
                                                    nestedSpendingInfo)

    <span class="hljs-keyword">val</span> scriptSigF = missingOpSigComponentF.map { sigComponent =&gt;
      <span class="hljs-type">ConditionalScriptSignature</span>(sigComponent.scriptSignature,
                                 spendingInfoToSatisfy.inputInfo.condition)
    }

    updateScriptSigInSigComponent(unsignedTx,
                                  inputIndex.toInt,
                                  output,
                                  scriptSigF)
  }
}
<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">ConditionalSigner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConditionalSigner</span></span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="step-9-add-to-bitcoinsignersign"></a><a href="#step-9-add-to-bitcoinsignersign" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 9: Add to BitcoinSigner.sign</h2>
<p>We must now add the new signing functionality from the previous step to the general-purpose signing functions by adding a new <code>case</code> for your new <code>InputInfo</code> type in the <code>match</code> within <code>BitcoinSigner.sign</code>. In the case of <code>P2PKWithTimeout</code>, this looks like:</p>
<pre><code class="hljs css language-scala">spendingInfoToSatisfy.inputInfo <span class="hljs-keyword">match</span> {
      <span class="hljs-comment">//...</span>
      <span class="hljs-keyword">case</span> p2pKWithTimeout: <span class="hljs-type">P2PKWithTimeoutInputInfo</span> =&gt;
              <span class="hljs-type">P2PKWithTimeoutSigner</span>.sign(spendingInfo,
                                         unsignedTx,
                                         spendingFrom(p2pKWithTimeout))
      <span class="hljs-comment">//...</span>
    }
</code></pre>
<p>We have now fully implemented the new script type! But have we done it correctly? We must now add the new script type to the Bitcoin-S test framework so that our scripts get added to existing Bitcoin-S property-based tests.</p>
<h2><a class="anchor" aria-hidden="true" id="step-10-add-to-scriptgenerators"></a><a href="#step-10-add-to-scriptgenerators" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 10: Add to ScriptGenerators</h2>
<p>The first step to adding our new script type to Bitcoin-S property-based tests is creating generators for our new <code>ScriptPubKey</code> and <code>ScriptSignature</code> types in <code>ScriptGenerators.scala</code>.</p>
<p>It is important to note that in the current Bitcoin-S generator framework for <code>ScriptPubKey</code>s, all conditionals always spend only their <code>OP_TRUE</code> cases.</p>
<h3><a class="anchor" aria-hidden="true" id="scriptpubkey-generator"></a><a href="#scriptpubkey-generator" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ScriptPubKey Generator</h3>
<p>Let's start by creating a generator for our <code>ScriptPubKey</code>, this generator should also return the private keys that were used to create the <code>ScriptPubKey</code>. To construct this <code>Gen</code>, you will likely need to use other generators for the internal structures in your script such as keys and lock times. For <code>P2PKWithTimeout</code> this looks like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p2pkWithTimeoutScriptPubKey</span></span>: <span class="hljs-type">Gen</span>[
    (<span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>, <span class="hljs-type">Seq</span>[<span class="hljs-type">ECPrivateKey</span>])] =
    <span class="hljs-keyword">for</span> {
      privKey &lt;- <span class="hljs-type">CryptoGenerators</span>.privateKey
      timeoutPrivKey &lt;- <span class="hljs-type">CryptoGenerators</span>.privateKey
      lockTime &lt;- <span class="hljs-type">NumberGenerator</span>.timeLockScriptNumbers
    } <span class="hljs-keyword">yield</span> {
      (<span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>(privKey.publicKey,
                                   lockTime,
                                   timeoutPrivKey.publicKey),
       <span class="hljs-type">Vector</span>(privKey, timeoutPrivKey))
    }
</code></pre>
<p>Note that the private key used in the <code>OP_TRUE</code> case is the <code>head</code> of the <code>Seq[ECPrivateKey]</code> returned. This makes it possible for tests that only spend the <code>OP_TRUE</code> case to find the correct key, as it is expected to be the first one.</p>
<p>We must now add this <code>Gen</code> to all of the following <code>def</code>s in <code>ScriptGenerators.scala</code>: <code>randomNonP2SHScriptPubKey, scriptPubKey, nonWitnessScriptPubKey, nonConditionalRawScriptPubKey, rawScriptPubKey</code>, and if your <code>ScriptPubKey</code> has no lock times, you must also add the above <code>Gen</code> to <code>nonConditionalNonLocktimeRawScriptPubKey, nonLocktimeRawScriptPubKey</code> as well.</p>
<h3><a class="anchor" aria-hidden="true" id="scriptsignature-generator"></a><a href="#scriptsignature-generator" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ScriptSignature Generator</h3>
<p>We must also create a generator for our <code>ScriptSignature</code> type, even if we did not introduce a new <code>ScriptSignature</code> type (in our example of <code>P2PKWithTimeout</code> we use a specific form of <code>ConditionalScriptSignature</code>). Once again you will likely need to use other existing generators. For <code>P2PKWithTimeoutScriptSignature</code>, this looks like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p2pkWithTimeoutScriptSignature</span></span>: <span class="hljs-type">Gen</span>[<span class="hljs-type">ConditionalScriptSignature</span>] =
    <span class="hljs-keyword">for</span> {
      privKey &lt;- <span class="hljs-type">CryptoGenerators</span>.privateKey
      hash &lt;- <span class="hljs-type">CryptoGenerators</span>.doubleSha256Digest
      hashType &lt;- <span class="hljs-type">CryptoGenerators</span>.hashType
      signature = <span class="hljs-type">ECDigitalSignature</span>.fromBytes(
        privKey.sign(hash).bytes ++ <span class="hljs-type">ByteVector</span>.fromByte(hashType.byte))
      beforeTimeout &lt;- <span class="hljs-type">NumberGenerator</span>.bool
    } <span class="hljs-keyword">yield</span> <span class="hljs-type">P2PKWithTimeoutScriptSignature</span>(beforeTimeout, signature)
</code></pre>
<p>We now add this <code>Gen</code> to <code>scriptSignature: Gen[ScriptSignature]</code> as well as adding a case for our new <code>ScriptPubKey</code> type in <code>pickCorrespondingScriptSignature</code> which should return our new <code>ScriptSignature</code> generator.  If our <code>ScriptPubKey</code> does not have any lock times, you should also add this script signature <code>Gen</code> to <code>nonLockTimeConditionalScriptSignature</code> and <code>randomNonLockTimeScriptSig</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="scriptpubkey-with-paired-scriptsignature-generator"></a><a href="#scriptpubkey-with-paired-scriptsignature-generator" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ScriptPubKey with Paired ScriptSignature Generator</h3>
<p>Lastly, we need to construct a generator that returns both a <code>ScriptPubKey</code> and a <code>ScriptSignature</code> signing that that <code>ScriptPubKey</code>. All keys used in signing should also be returned. This all should be done by using the above <code>ScriptPubKey</code> generator, then constructing an <code>ScriptSignature</code> for your type where all actual signatures are <code>EmptyDigitalSignature</code>s. A <code>UTXOSatisfyingInfo</code> should then be constructed for the generated <code>ScriptPubKey</code> (using the private keys generated in the same line). Finally, a <code>TxSignatureComponent</code> should be created by using the new <code>Signer</code> for our script type. From this <code>TxSignatureComponent</code>, a <code>ScriptSignature</code> is readily available. For <code>P2PKWithTimeout</code>, this generator looks like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">signedP2PKWithTimeoutScriptSignature</span></span>: <span class="hljs-type">Gen</span>[
    (<span class="hljs-type">ConditionalScriptSignature</span>, <span class="hljs-type">P2PKWithTimeoutScriptPubKey</span>, <span class="hljs-type">ECPrivateKey</span>)] =
    <span class="hljs-keyword">for</span> {
      (spk, privKeys) &lt;- p2pkWithTimeoutScriptPubKey
      hashType &lt;- <span class="hljs-type">CryptoGenerators</span>.hashType
    } <span class="hljs-keyword">yield</span> {
      <span class="hljs-keyword">val</span> emptyScriptSig = <span class="hljs-type">P2PKWithTimeoutScriptSignature</span>(beforeTimeout = <span class="hljs-literal">true</span>,
                                                          <span class="hljs-type">ECDigitalSignature</span>.empty)
      <span class="hljs-keyword">val</span> (creditingTx, outputIndex) =
        <span class="hljs-type">TransactionGenerators</span>.buildCreditingTransaction(spk)
      <span class="hljs-keyword">val</span> (spendingTx, inputIndex) = <span class="hljs-type">TransactionGenerators</span>
        .buildSpendingTransaction(creditingTx, emptyScriptSig, outputIndex)
      <span class="hljs-keyword">val</span> spendingInfo = <span class="hljs-type">UTXOSatisfyingInfo</span>(
        <span class="hljs-type">P2PKWithTimeoutInputInfo</span>(
          <span class="hljs-type">TransactionOutPoint</span>(creditingTx.txIdBE, inputIndex),
          creditingTx.outputs(outputIndex.toInt).value,
          spk,
          isBeforeTimeout = <span class="hljs-literal">true</span>),
        privKeys.toVector,
        hashType
      )
      <span class="hljs-keyword">val</span> txSigComponentF = <span class="hljs-type">P2PKWithTimeoutSigner</span>.sign(spendingInfo,
                                                       spendingTx)
      <span class="hljs-keyword">val</span> txSigComponent = <span class="hljs-type">Await</span>.result(txSigComponentF, timeout)
      <span class="hljs-keyword">val</span> signedScriptSig =
        txSigComponent.scriptSignature.asInstanceOf[<span class="hljs-type">ConditionalScriptSignature</span>]

      (signedScriptSig, spk, privKeys.head)
    }
</code></pre>
<p>I strongly advise you also look at at least one other <code>Gen</code> of this kind before writing your own.</p>
<h2><a class="anchor" aria-hidden="true" id="step-11-add-to-creditingtxgen"></a><a href="#step-11-add-to-creditingtxgen" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 11: Add to CreditingTxGen</h2>
<p>Now that we have generators constructed for <code>ScriptPubKey</code>s, <code>ScriptSignature</code>s and their pairings completed, we will create a generator for our type's <code>SpendingInfoFull</code>. This should usually be as simple as mapping on the <code>ScriptPubKey</code> generator in <code>ScriptGenerators</code> and calling <code>build</code> (within <code>CreditinTxGen.scala</code>). We then also create another generator which returns lists of <code>SpendingInfo</code>s generated by the previous <code>Gen</code>. For <code>P2PKWithTimeout</code>, this looks like:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p2pkWithTimeoutOutput</span></span>: <span class="hljs-type">Gen</span>[<span class="hljs-type">UTXOSatisfyingInfo</span>[<span class="hljs-type">InputInfo</span>]] = {
    <span class="hljs-type">ScriptGenerators</span>.p2pkWithTimeoutScriptPubKey.flatMap { p2pkWithTimeout =&gt;
      build(p2pkWithTimeout._1, <span class="hljs-type">Seq</span>(p2pkWithTimeout._2.head), <span class="hljs-type">None</span>, <span class="hljs-type">None</span>)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">p2pkWithTimeoutOutputs</span></span>: <span class="hljs-type">Gen</span>[<span class="hljs-type">Seq</span>[<span class="hljs-type">UTXOSatisfyingInfo</span>[<span class="hljs-type">InputInfo</span>]]] = {
    <span class="hljs-type">Gen</span>.choose(min, max).flatMap(n =&gt; <span class="hljs-type">Gen</span>.listOfN(n, p2pkWithTimeoutOutput))
  }
</code></pre>
<p>We must then add our output <code>Gen</code> to one of <code>cltvOutputGens</code> or <code>nonCLTVOutputGens</code> depending on whether the <code>ScriptPubKey</code> type has CLTVs (absolute lock times) or not. We must also add our output <code>Gen</code> to <code>nonP2SHOutput</code>, and also to <code>nonSHOutput</code> and <code>nonP2WSHOutput</code> in the case that your <code>ScriptPubKey</code> type has no CLTVs.</p>
<h2><a class="anchor" aria-hidden="true" id="step-12-fix-all-non-exhaustive-matches"></a><a href="#step-12-fix-all-non-exhaustive-matches" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 12: Fix all Non-Exhaustive Matches</h2>
<p>All we have left is to clean up our code and make sure that nothing has been missed. Within an <code>sbt</code> terminal, you should run the following sequence of commands:</p>
<pre><code class="hljs css language-bashrc">clean
<span class="hljs-keyword">project</span> coreTest
<span class="hljs-keyword">test</span>:compile
</code></pre>
<p>This should have quite a lengthy output but we are only interested in any compiler errors there may be, as well as non-exhaustive match compiler warnings. You should first fix any compiler errors you encounter, and then you can get the warnings again by running <code>clean</code> and then running <code>test:compile</code> again.</p>
<p>The warnings we're interested in should look something like this:</p>
<pre><code class="hljs">[warn] <span class="hljs-regexp">/home/</span>nkohen<span class="hljs-regexp">/Desktop/</span>SuredBits<span class="hljs-regexp">/bitcoin-s-core/</span>testkit<span class="hljs-regexp">/src/</span>main<span class="hljs-regexp">/scala/</span>org<span class="hljs-regexp">/bitcoins/</span>testkit<span class="hljs-regexp">/core/</span>gen/ScriptGenerators.<span class="hljs-string">scala:</span><span class="hljs-number">524</span>:<span class="hljs-number">59</span>: match may not be exhaustive.
[warn] It would fail on the following <span class="hljs-string">input:</span> P2PKWithTimeoutScriptPubKeyImpl(_)
[warn]       <span class="hljs-string">scriptPubKey:</span> ScriptPubKey): Gen[ScriptSignature] = scriptPubKey match {
[warn]                                                           ^
[warn] one warning found
</code></pre>
<p>You may get these warnings for your new <code>ScriptSignature</code> type as well. These are places where the compiler expects there to be defined functionality in a pattern match where one of our new types is a possibility, but for which no functionality is defined. You must go to each of these warnings and add a <code>case</code> for the relevant new type, or add this new type to an existing case when applicable.</p>
<h2><a class="anchor" aria-hidden="true" id="step-13-run-tests-and-debug"></a><a href="#step-13-run-tests-and-debug" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Step 13: Run tests and debug</h2>
<p>Lastly, once everything is compiling nicely, all that is left is to run tests and debug. While within an <code>sbt</code> terminal session, run the following two commands to run the relevant tests:</p>
<pre><code class="hljs">project coreTest
<span class="hljs-keyword">test
</span></code></pre>
<p>If all tests pass we are all done! If you encounter any test failures, you can re-run individual tests using the <code>testOnly</code> command which must be given the full name of the test you wish to run (these names should be at the bottom of the testing output and look something like <code>org.bitcoins.core.script.interpreter.ScriptInterpreterTest</code>).</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2/11/2021 by Chris Stewart</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/core/hd-keys"><span class="arrow-prev">← </span><span>HD Key Generation</span></a><a class="docs-next button" href="/docs/core/spending-info"><span>Signing Transactions</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#step-0-design-philosophy">Step 0: Design Philosophy</a></li><li><a href="#step-1-create-a-new-scriptpubkey-trait">Step 1: Create a New ScriptPubKey Trait</a></li><li><a href="#step-2-create-companion-object">Step 2: Create Companion Object</a></li><li><a href="#step-3-add-to-relevant-fromasm-methods">Step 3: Add to Relevant fromAsm Methods</a></li><li><a href="#step-4-create-a-scriptsignature-if-necessary">Step 4: Create a ScriptSignature If Necessary</a></li><li><a href="#step-5-add-to-scriptsignaturefromasm-if-applicable">Step 5: Add to ScriptSignature.fromAsm If Applicable</a></li><li><a href="#step-6-create-relevant-inputinfo">Step 6: Create Relevant InputInfo</a><ul class="toc-headings"><li><a href="#non-nesting-input-info">Non-Nesting Input Info</a></li><li><a href="#nested-spending-info">Nested Spending Info</a></li></ul></li><li><a href="#step-7-add-to-relevant-apply-methods">Step 7: Add to Relevant Apply Methods</a></li><li><a href="#step-8-create-a-signer">Step 8: Create a Signer</a><ul class="toc-headings"><li><a href="#non-nested-single-key-spending-info">Non-Nested Single-Key Spending Info</a></li><li><a href="#non-nested-multi-key-spending-info">Non-Nested Multi-Key Spending Info</a></li><li><a href="#nested-spending-info-1">Nested Spending Info</a></li></ul></li><li><a href="#step-9-add-to-bitcoinsignersign">Step 9: Add to BitcoinSigner.sign</a></li><li><a href="#step-10-add-to-scriptgenerators">Step 10: Add to ScriptGenerators</a><ul class="toc-headings"><li><a href="#scriptpubkey-generator">ScriptPubKey Generator</a></li><li><a href="#scriptsignature-generator">ScriptSignature Generator</a></li><li><a href="#scriptpubkey-with-paired-scriptsignature-generator">ScriptPubKey with Paired ScriptSignature Generator</a></li></ul></li><li><a href="#step-11-add-to-creditingtxgen">Step 11: Add to CreditingTxGen</a></li><li><a href="#step-12-fix-all-non-exhaustive-matches">Step 12: Fix all Non-Exhaustive Matches</a></li><li><a href="#step-13-run-tests-and-debug">Step 13: Run tests and debug</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/favicon.ico" alt="bitcoin-s" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/en/getting-started">Getting Started</a><a href="/docs/en/core/core-intro">Guides</a><a href="/api/org/bitcoins">API Reference</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://join.slack.com/t/suredbits/shared_invite/zt-eavycu0x-WQL7XOakzQo8tAy7jHHZUw" target="_blank" rel="noreferrer noopener">Slack</a><a href="https://gitter.im/bitcoin-s-core/">Gitter chat</a></div><div><h5>More</h5><a href="https://github.com/bitcoin-s/bitcoin-s">GitHub</a><a class="github-button" href="https://github.com/bitcoin-s/bitcoin-s" data-icon="octicon-star" data-count-href="/bitcoin-s/bitcoin-s-core/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2025 Suredbits &amp; the bitcoin-s developers</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0a510688bf8448e19aeb380377d328d3',
                indexName: 'bitcoin-s',
                inputSelector: '#search_input_react'
              });
            </script></body></html>