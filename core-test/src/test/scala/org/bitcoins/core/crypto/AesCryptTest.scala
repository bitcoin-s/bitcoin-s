package org.bitcoins.core.crypto

import org.bitcoins.testkit.core.gen.{NumberGenerator, StringGenerators}
import org.bitcoins.testkit.util.BitcoinSUnitTest
import org.scalatest.Assertion
import scodec.bits.{ByteVector, HexStringSyntax}

class AesCryptTest extends BitcoinSUnitTest {
  behavior of "AesEncrypt"

  val password = AesPassword("PASSWORD")
  val badPassword = AesPassword("BAD_PASSWORD")
  val emptyPassword = AesPassword("")

  /**
    * The test vectors in this test was generated by using
    * https://cryptii.com/pipes/aes-encryption
    *
    * This test only tests decryption of hard coded vectors because a random IV
    * (initialization vector) is generated each time something is encrypted.
    * Therefore encrypting something multiple times would yield a different
    * answer (and we have to store the IV with the encrypted data in the
    * AesEncryptedData case class. We also store a salt. This is not related
    * to the AES encryption itself, but the key stretching function we use to
    * transform the user provided pass phrase to a proper AES key. To go from
    * hard coded values below to something you can put into the online encryption
    * site above, you would do something like this:
    *
    * import org.bitcoins.core.crypto._
    * import scodec.bits._
    *
    * val pass = AesPassword("foobar")
    *
    * // input this into the plaintext box
    * val plainText = hex"abcdef"
    * val Right(encrypted) = AesCrypt.encrypt(plainText, pass)
    *
    * val key = AesCrypt.getSecretKey(pass, encrypted.salt)
    * val encodedKey = ByteVector(key.getEncoded).toHex // this goes in the "KEY" field
    *
    * val iv = encrypted.iv.toHex // this goes in the "IV" field
    *
    * // compare this against the encrypted text that gets outputted
    * val cipherText = encrypted.cipherText.toHex
    */
  it must "decrypt some hard coded test vectors" in {
    case class TestVector(
        plainText: ByteVector,
        password: AesPassword,
        encryptedData: AesEncryptedData,
        expectedSecretKey: String)

    def runTest(testVector: TestVector): Assertion = {
      val TestVector(plainText, password, encryptedData, expectedSecretKey) =
        testVector

      val secretKey = AesCrypt.getSecretKey(password, encryptedData.salt)
      val Right(decrypted) = AesCrypt.decrypt(encryptedData, password)
      assert(decrypted == plainText)

      val encodedSecretKey = ByteVector(secretKey.getEncoded).toHex
      assert(encodedSecretKey == expectedSecretKey)
    }
    val first =
      TestVector(
        plainText = hex"76fe35880055e1fac950f484a815cd22",
        password = AesPassword("2eefdf6ee2dbca83e7b7648a8f9d1897"),
        encryptedData = AesEncryptedData(
          cipherText =
            hex"b8bbad991c2e64999a56bca47a8970da0001870030815c9233a758abb6d75777",
          iv = hex"889dc64377f6d993ef713c995f9c1ee5",
          salt = AesSalt(hex"48bd3bcdc9abe0dfa8870ec41129c584")
        ),
        expectedSecretKey =
          "e395c5b6e829e9310edfbec3d1b921725fbd00ec96616a58ae97afc59b98520e"
      )

    runTest(first)

    val second = TestVector(
      plainText = hex"3a4f73044d035017d91883ebfc113da7",
      password = AesPassword("5ce91f97ed28fd5d1172e23eb17b1baa"),
      encryptedData = AesEncryptedData(
        cipherText =
          hex"c95b695ab84086b1038d2eb23118e4dc1412c7e9095db2003d9eee6fc448ddb0",
        iv = hex"3f91d29f81d48174b25a3d0143eb833c",
        salt = AesSalt(
          hex"0898496233e7bfb43b44cf5f9a72433e61cf4acc5546a2b721aaadfde6b3f0b0")
      ),
      expectedSecretKey =
        "04e351eb63ce04aa85994d9c989b7e2496064944040429254a296f282fd51147"
    )

    runTest(second)

    val third = TestVector(
      plainText = hex"5f6a62cb52309db4573bfed807e07bb2",
      password = AesPassword("c62bea08786568283dafabde6d699e0f"),
      encryptedData = AesEncryptedData(
        cipherText =
          hex"9887677c55da441ed82ca399f5ed62f07c11feacff127ddb24a4c992637ead52",
        iv = hex"455014871cd34f8dcfd7c1e387987bff",
        salt = AesSalt(
          hex"10eb6a9d7feda89fdfe9e5a1a490772c02ac2ee62a606964215ce797d2bb1ac2")
      ),
      expectedSecretKey =
        "9a3ab030cf31aa804a058ca190e57acd57894f816aa11229fd05137f625ac87d"
    )

    runTest(third)

  }

  it must "fail when encrypting with an empty password" in {
    val encryptE =
      AesCrypt.encrypt(plainText = hex"abcdef", password = emptyPassword)
    encryptE match {
      case Right(_)                                  => fail("Was able to encrypt with an empty password!")
      case Left(AesException.EmptyPasswordException) => succeed
      case Left(exc)                                 => fail("Failed with unexpected exception", exc)
    }
  }

  it must "fail when decrypting with an empty password" in {
    val encrypted = AesCrypt.encryptExc(plainText = hex"123456789", password)
    AesCrypt.decrypt(encrypted, emptyPassword) match {
      case Right(_)                                  => fail("Was able to decrypt with an empty password!")
      case Left(AesException.EmptyPasswordException) => succeed
      case Left(exc)                                 => fail("Failed with unexpected exception", exc)
    }

  }

  it must "have encryption and decryption symmetry" in {
    forAll(NumberGenerator.bytevector,
           StringGenerators.genString.suchThat(_.nonEmpty)) {
      (bytes, passwordStr) =>
        val password = AesPassword(passwordStr)
        val encrypted = AesCrypt.encrypt(bytes, password).right.get
        AesCrypt.decrypt(encrypted, password) match {
          case Right(decrypted) => assert(decrypted == bytes)
          case Left(exc)        => fail(exc)
        }
    }
  }

  it must "fail to decrypt with the wrong password" in {
    forAll(NumberGenerator.bytevector) { bytes =>
      val encrypted = AesCrypt.encryptExc(bytes, password)
      val decryptedE = AesCrypt.decrypt(encrypted, badPassword)
      decryptedE match {
        case Right(decrypted) =>
          assert(decrypted != bytes)
        case Left(exc) => assert(exc == AesException.BadPasswordException)
      }
    }
  }
}
