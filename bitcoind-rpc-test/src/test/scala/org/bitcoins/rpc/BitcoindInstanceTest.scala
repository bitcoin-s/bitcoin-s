package org.bitcoins.rpc

import org.bitcoins.core.config.RegTest
import org.bitcoins.rpc.client.common.BitcoindRpcClient
import org.bitcoins.rpc.config.{
  BitcoindAuthCredentials,
  BitcoindConfig,
  BitcoindInstanceLocal,
  BitcoindInstanceRemote,
  BitcoindRpcAppConfig
}
import org.bitcoins.rpc.util.RpcUtil
import org.bitcoins.testkit.rpc.BitcoindRpcTestUtil
import org.bitcoins.testkit.util.{BitcoindRpcTest, FileUtil}
import org.scalatest.compatible.Assertion

import java.net.URI
import scala.concurrent.Future

class BitcoindInstanceTest extends BitcoindRpcTest {

  /** Tests that the client can call the isStartedF method without throwing and
    * then start
    */
  private def testClientStart(client: BitcoindRpcClient): Future[Assertion] =
    synchronized {
      clientAccum += client
      for {
        firstStarted <- client.isStartedF
        _ <- startClient(client)
        secondStarted <- client.isStartedF
        _ <- client.getBalance
      } yield {
        assert(!firstStarted)
        assert(secondStarted)
      }
    }

  behavior of "BitcoindInstance"

  it should "start a bitcoind with cookie based authentication" in {
    val confStr = s"""
                     |regtest=1
                     |daemon=1
                     |[regtest]
                     |port=${RpcUtil.randomPort}
                     |rpcport=${RpcUtil.randomPort}
    """.stripMargin

    val conf = BitcoindConfig(confStr, FileUtil.tmpDir())
    val instance =
      BitcoindInstanceLocal.fromConfig(conf,
                                       BitcoindRpcTestUtil.newestBitcoindBinary)
    assert(
      instance.authCredentials
        .isInstanceOf[BitcoindAuthCredentials.CookieBased]
    )

    val cli = BitcoindRpcClient(instance)
    testClientStart(cli)
  }

  it should "start a bitcoind with user and password based authentication" in {
    val confStr = s"""
                     |daemon=1
                     |regtest=1
                     |rpcuser=foobar
                     |rpcpassword=barfoo
                     |[regtest]
                     |bind=127.0.0.1:${RpcUtil.randomPort}
                     |rpcport=${RpcUtil.randomPort}
      """.stripMargin

    val conf = BitcoindConfig(confStr, FileUtil.tmpDir())
    val instance =
      BitcoindInstanceLocal.fromConfig(conf,
                                       BitcoindRpcTestUtil.newestBitcoindBinary)
    assert(
      instance.authCredentials
        .isInstanceOf[BitcoindAuthCredentials.PasswordBased]
    )
    testClientStart(BitcoindRpcClient(instance))
  }

  // the values in this conf was generated by executing
  // rpcauth.py from Bitcoin Core like this:
  //
  // ❯ ./rpcauth.py bitcoin-s strong_password
  // String to be appended to bitcoin.conf:
  // rpcauth=bitcoin-s:6d7580be1deb4ae52bc4249871845b09$82b282e7c6493f6982a5a7af9fbb1b671bab702e2f31bbb1c016bb0ea1cc27ca
  // Your password:
  // strong_password
  it should "start a bitcoind with auth based authentication" in {
    val port = RpcUtil.randomPort
    val rpcPort = RpcUtil.randomPort
    val confStr = s"""
                     |daemon=1
                     |rpcauth=bitcoin-s:6d7580be1deb4ae52bc4249871845b09$$82b282e7c6493f6982a5a7af9fbb1b671bab702e2f31bbb1c016bb0ea1cc27ca
                     |regtest=1
                     |[regtest]
                     |bind=127.0.0.1:${port}
                     |rpcport=${rpcPort}
       """.stripMargin

    val bitcoindDatadir = FileUtil.tmpDir()
    val conf = BitcoindConfig(confStr, bitcoindDatadir)
    val authCredentials =
      BitcoindAuthCredentials.PasswordBased(
        username = "bitcoin-s",
        password = "strong_password"
      )
    val bitcoindRpcAppConfig =
      BitcoindRpcAppConfig(conf.datadir.toPath,
                           Vector.empty,
                           authCredentinalsOpt = Some(authCredentials))
    val instance =
      BitcoindInstanceLocal(
        network = RegTest,
        uri = new URI(s"http://localhost:$port"),
        rpcUri = new URI(s"http://localhost:$rpcPort"),
        binary = BitcoindRpcTestUtil.newestBitcoindBinary,
        bitcoindDatadir = bitcoindDatadir
      )(system, bitcoindRpcAppConfig)

    testClientStart(BitcoindRpcClient(instance))
  }

  it should "connect us to a remote bitcoind instance and ping it successfully" in {
    val port = RpcUtil.randomPort
    val rpcPort = RpcUtil.randomPort
    val confStr = s"""
                     |daemon=1
                     |rpcauth=bitcoin-s:6d7580be1deb4ae52bc4249871845b09$$82b282e7c6493f6982a5a7af9fbb1b671bab702e2f31bbb1c016bb0ea1cc27ca
                     |regtest=1
                     |[regtest]
                     |bind=127.0.0.1:${port}
                     |rpcport=${rpcPort}
       """.stripMargin

    val bitcoindDatadir = FileUtil.tmpDir()
    val conf = BitcoindConfig(config = confStr, datadir = bitcoindDatadir)
    val authCredentials =
      BitcoindAuthCredentials.PasswordBased(
        username = "bitcoin-s",
        password = "strong_password"
      )
    val bitcoindRpcAppConfig =
      BitcoindRpcAppConfig(conf.datadir.toPath.getParent,
                           Vector.empty,
                           authCredentinalsOpt = Some(authCredentials))
    val instance =
      BitcoindInstanceLocal(
        network = RegTest,
        uri = new URI(s"http://localhost:$port"),
        rpcUri = new URI(s"http://localhost:$rpcPort"),
        binary = BitcoindRpcTestUtil.newestBitcoindBinary,
        bitcoindDatadir = bitcoindDatadir
      )(system, bitcoindRpcAppConfig)

    val client =
      BitcoindRpcClient(instance)
    for {
      _ <- startClient(client)
      remoteInstance = BitcoindInstanceRemote(
        network = instance.network,
        uri = instance.uri,
        rpcUri = instance.rpcUri,
        zmqConfig = instance.zmqConfig,
        proxyParams = None
      )(system, bitcoindRpcAppConfig)
      remoteClient = new BitcoindRpcClient(remoteInstance)(system)
      _ <- remoteClient.start()
      _ <- remoteClient.isStartedF.map {
        case false =>
          client.stop()
          fail("Couldn't ping remote instance")
        case true =>
      }
      _ <- remoteClient.stop()

    } yield succeed

  }

}
